{"name":"Node TAP","tagline":"Test Anything Protocol tools for node","body":"[![Build Status](https://travis-ci.org/tapjs/node-tap.svg?branch=master)](https://travis-ci.org/tapjs/node-tap/) [![Build Status](https://ci.appveyor.com/api/projects/status/913p1ypf21gf4leu?svg=true)](https://ci.appveyor.com/project/isaacs/node-tap) [![Coverage Status](https://coveralls.io/repos/tapjs/node-tap/badge.svg?branch=master&service=github)](https://coveralls.io/github/tapjs/node-tap?branch=master)\r\n\r\nIncludes a command line test runner for consuming TAP-generating\r\ntest scripts, and a JavaScript framework for writing such scripts.\r\n\r\nBuilt-in support for code coverage (including instrumenting child\r\nprocesses).  Coverage is printed to the command line in a terse table\r\nby default, but tap can also open up your web browser to a pretty\r\nreport if you add `--coverage-report=lcov` to the command.\r\n\r\nWorks with all exception-throwing assertion libraries (chai, should,\r\nnode's built-in `require('assert')`, or just throwing yourself) but\r\nalso has a [huge library of built-in assertions](#asserts) that you\r\ncan use if you want to have each one reported as successes.\r\n\r\nOutputs in a wide variety of formats using the\r\n[tap-mocha-reporter](http://npm.im/tap-mocha-reporter) module.  (That\r\nis, you can get spec output by doing `-Rspec`.  The default output is\r\ncalled 'classic', based on tap 0.x's output, but with color and timing\r\ninfo.)\r\n\r\n## USAGE\r\n\r\nWrite your tests in JavaScript\r\n\r\n```javascript\r\nvar tap = require('tap')\r\n\r\n// you can test stuff just using the top level object.\r\n// no suites or subtests required.\r\n\r\ntap.equal(1, 1, 'check if numbers still work')\r\ntap.notEqual(1, 2, '1 should not equal 2')\r\n\r\n// also you can group things into sub-tests.\r\n// Sub-tests will be run in sequential order always,\r\n// so they're great for async things.\r\n\r\ntap.test('first stuff', function (t) {\r\n  t.ok(true, 'true is ok')\r\n  t.similar({a: [1,2,3]}, {a: [1,2,3]})\r\n  // call t.end() when you're done\r\n  t.end()\r\n})\r\n\r\n// If you have a bunch of setup stuff that MUST work or else\r\n// the rest of the tests are not worth running, then you can\r\n// pass `{ bail: true }` to make it bail out on failure.\r\n\r\ntap.test('must succeed or all is lost', { bail: true }, function (t) {\r\n  db = new DataBorscht()\r\n  t.ok(db, 'borscht setup must succeed')\r\n  t.end()\r\n})\r\n\r\n// You can also bail out based on specific conditions, or with a\r\n// different error message of your choosing.\r\ntap.test('must mostly succeed or all is lost', function (t) {\r\n  db = new DataBorscht()\r\n\r\n  t.ok(db, 'borscht setup')\r\n  if (!db) {\r\n    t.bailout('the borscht is lost.  I cannot continue.')\r\n    return\r\n  }\r\n\r\n  t.ok(db.connection, 'db must have connection')\r\n  t.ok(db.username, 'db must have username')\r\n  t.equal(db.color, 'red', 'borscht should be red')\r\n  if (!t.passing())\r\n    t.bailout('something weird with the data borscht.')\r\n\r\n  t.end()\r\n})\r\n\r\n// you can specify a 'plan' if you know how many\r\n// tests there will be in advance. Handy when\r\n// order is irrelevant and things happen in parallel.\r\n\r\n// Note that the function name is used if no name is provided!\r\ntap.test(function planned (t) {\r\n  t.plan(2)\r\n  setTimeout(function () {\r\n    t.ok(true, 'a timeout')\r\n  })\r\n  setTimeout(function () {\r\n    t.ok(true, 'b timeout')\r\n  })\r\n})\r\n\r\n// you can do `var test = require('tap').test` if you like\r\n// it's pre-bound to the root tap object.\r\n\r\nvar test = require('tap').test\r\n\r\n// subtests can have subtests\r\ntest(function parent (t) {\r\n  t.test(function child (tt) {\r\n    tt.throws(function () {\r\n      throw new Error('fooblz')\r\n    }, {\r\n      message: 'fooblz'\r\n    }, 'throw a fooblz')\r\n\r\n    // throws also uses function name if no name provided\r\n    tt.throws(function throw_whatever () { throw 1 })\r\n\r\n    tt.end()\r\n  })\r\n\r\n  t.end()\r\n})\r\n\r\n// thrown errors just fail the current test, so you can\r\n// also use your own assert library if you like.\r\n// Of course, this means it won't be able to print out the\r\n// number of passing asserts, since passes will be silent.\r\n\r\ntest('my favorite assert lib', function (t) {\r\n  var assert = require('assert')\r\n  assert.ok(true, 'true is ok')\r\n  assert.equal(1, 1, 'math works')\r\n\r\n  // Since it can't read the plan, using a custom assert lib\r\n  // means that you MUST use t.end()\r\n  t.end()\r\n})\r\n\r\n// You can mark tests as 'todo' either using a conf object,\r\n// or simply by omitting the callback.\r\ntest('solve halting problem')\r\ntest('prove p=np', { todo: true }, function (t) {\r\n  // i guess stuff goes here\r\n  t.fail('traveling salesmen must pack their own bags')\r\n  t.end()\r\n})\r\n\r\n// Prefer mocha/rspec/lab style global objects?\r\n// Got you covered.  This is a little experimental,\r\n// patches definitely welcome.\r\ntap.mochaGlobals()\r\ndescribe('suite ride bro', function () {\r\n  it('should have a wheel', function () {\r\n    assert.ok(thingie.wheel, 'wheel')\r\n  })\r\n  it('can happen async', function (done) {\r\n    setTimeout(function () {\r\n      assert.ok('ok')\r\n      done()\r\n    })\r\n  })\r\n})\r\n\r\n// Read on for a complete list of asserts, methods, etc.\r\n```\r\n\r\nYou can run tests using the `tap` executable.  Put this in your\r\npackage.json file:\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"test\": \"tap test/*.js\"\r\n  }\r\n}\r\n```\r\n\r\nand then you can run `npm test` to run your test scripts.\r\n\r\nCommand line behavior and flags:\r\n\r\n```\r\n$ tap -h\r\nUsage:\r\n  tap [options] <files>\r\n\r\nExecutes all the files and interprets their output as TAP\r\nformatted test result data.\r\n\r\nTo parse TAP data from stdin, specify \"-\" as a filename.\r\n\r\nShort options are parsed gnu-style, so for example '-bCRspec' would be\r\nequivalent to '--bail --no-color --reporter=spec'\r\n\r\nOptions:\r\n\r\n  -c --color                  Use colors (Default for TTY)\r\n\r\n  -C --no-color               Do not use colors (Default for non-TTY)\r\n\r\n  -b --bail                   Bail out on first failure\r\n\r\n  -B --no-bail                Do not bail out on first failure (Default)\r\n\r\n  -R<type> --reporter=<type>  Use the specified reporter.  Defaults to\r\n                              'classic' when colors are in use, or 'tap'\r\n                              when colors are disabled.\r\n\r\n                              Available reporters:\r\n                              classic doc dot dump html htmlcov json\r\n                              jsoncov jsonstream landing list markdown\r\n                              min nyan progress silent spec tap xunit\r\n\r\n  -s<file> --save=<file>      If <file> exists, then it should be a line-\r\n                              delimited list of test files to run.  If\r\n                              <file> is not present, then all command-line\r\n                              positional arguments are run.\r\n\r\n                              After the set of test files are run, any\r\n                              failed test files are written back to the\r\n                              save file.\r\n\r\n                              This way, repeated runs with -s<file> will\r\n                              re-run failures until all the failures are\r\n                              passing, and then once again run all tests.\r\n\r\n                              It's a good idea to .gitignore the file\r\n                              used for this purpose, as it will churn a\r\n                              lot.\r\n\r\n  --coverage --cov            Capture coverage information using 'nyc'\r\n\r\n                              If a COVERALLS_REPO_TOKEN environment\r\n                              variable is set, then coverage is\r\n                              captured by default and sent to the\r\n                              coveralls.io service. If a CODECOV_TOKEN\r\n                              environment variable is set, then coverage is\r\n                              captured by default and sent to the\r\n                              codecov.io service.\r\n\r\n  --no-coverage --no-cov      Do not capture coverage information.\r\n                              Note that if nyc is already loaded, then\r\n                              the coverage info will still be captured.\r\n\r\n  --coverage-report=<type>    Output coverage information using the\r\n                              specified istanbul/nyc reporter type.\r\n\r\n                              Default is 'text' when running on the\r\n                              command line, or 'text-lcov' when piping\r\n                              to coveralls or codecov.\r\n\r\n                              If 'lcov' is used, then the report will\r\n                              be opened in a web browser after running.\r\n\r\n                              This can be run on its own at any time\r\n                              after a test run that included coverage.\r\n\r\n  -t<n> --timeout=<n>         Time out test files after <n> seconds.\r\n                              Defaults to 30, or the value of the\r\n                              TAP_TIMEOUT environment variable.\r\n\r\n  -h --help                   print this thing you're looking at\r\n\r\n  -v --version                show the version of this program\r\n\r\n  -gc --expose-gc             Expose the gc() function to Node tests\r\n\r\n  --debug                     Run JavaScript tests with node --debug\r\n\r\n  --debug-brk                 Run JavaScript tests with node --debug-brk\r\n\r\n  --harmony                   Enable all Harmony flags in JavaScript tests\r\n\r\n  --strict                    Run JS tests in 'use strict' mode\r\n\r\n  --                          Stop parsing flags, and treat any additional\r\n                              command line arguments as filenames.\r\n```\r\n\r\n## Coverage\r\n\r\nThis module uses [nyc](http://npm.im/nyc) to track code coverage, even\r\nacross subprocess boundaries.  It is included by default, and there's\r\nnothing you need to do but enable it.  Adding coverage *will* make\r\nyour tests run slightly slower, but that's to be expected.\r\n\r\nTo generate coverage information, run your tests with the `--cov`\r\nargument.\r\n\r\nTo specify a report format, you can use `--coverage-report=<type>`.\r\nThe default type is `text`, which produces a pretty text-only table on\r\nthe terminal.  If you specify `--coverage-report=lcov`, then tap will\r\nattempt to open a web browser to view the report after the test run.\r\n\r\nIf you use this a lot, you may want to add `coverage` and\r\n`.nyc_output` to your `.gitignore` and/or `.npmignore` files.\r\n\r\n### Travis-CI and Coveralls.io/CodeCov.io Integration\r\n\r\nYou can very easily take advantage of continuous test coverage reports\r\nby using [Travis-CI](https://travis-ci.org) and\r\n[Coveralls](https://coveralls.io).\r\n\r\n1. Enable Travis-CI by signing up, enabling tests on your repo, and\r\n   adding a `.travis.yml` file to your repo.  You can use [this\r\n   module's .travis.yml file as an\r\n   example](https://github.com/isaacs/node-tap/blob/master/.travis.yml)\r\n2. Enable Coveralls.io or CodeCov.io by signing up, and adding the\r\n   repo.  Note the repo API token.\r\n3. Back at Travis-CI, add a private environment variable.  The name of\r\n   the environment variable is `COVERALLS_REPO_TOKEN` for Coveralls,\r\n   or `CODECOV_TOKEN` for CodeCov.io, and the value is the token you\r\n   got from Coveralls or CodeCov.\r\n4. When that token is set in the environment variable, `tap` will\r\n   automatically generate coverage information and send it to the\r\n   appropriate place.\r\n\r\n## API\r\n\r\n### tap = require('tap')\r\n\r\nThe root `tap` object is an instance of the Test class with a few\r\nslight modifications.\r\n\r\n1. The `tearDown()`, `plan()`, and `test()` methods are pre-bound onto\r\n   the root object, so that you don't have to call them as methods.\r\n2. By default, it pipes to stdout, so running a test directly just\r\n   dumps the TAP data for inspection.  (You can of course\r\n   `tap.unpipe(process.stdout)` if you want to direct it elsewhere.)\r\n3. Various other things are hung onto it for convenience, since it is\r\n   the main package export.\r\n4. The test ends automatically when `process.on('exit')` fires, so\r\n   there is no need to call `tap.end()` explicitly.\r\n5. Adding a `tearDown` function triggers `autoend` behavior.\r\n   Otherwise, the `end` would potentially never arrive, if for example\r\n   `tearDown` is used to close a server or cancel some long-running\r\n   process, because `process.on('exit')` would never fire of its own\r\n   accord.\r\n\r\n### tap.synonyms\r\n\r\nA list of all of the canonical assert methods and their synonyms.\r\n\r\n### tap.mochaGlobals()\r\n\r\nMethod that injects `describe()` and `it()` into the global\r\nenvironment for mocha-like BDD style test definition.\r\n\r\nThis feature is incomplete, experimental, and may change drastically\r\nin the future.  Feedback is welcome.\r\n\r\n### tap.Test\r\n\r\nThe `Test` class is the main thing you'll be touching when you use\r\nthis module.\r\n\r\nThe most common way to instantiate a `Test` object by calling the\r\n`test` method on the root or any other `Test` object.  The callback\r\npassed to `test(name, fn)` will receive a child `Test` object as its\r\nargument.\r\n\r\nA `Test` object is a Readable Stream.  Child tests automatically send\r\ntheir data to their parent, and the root `require('tap')` object pipes\r\nto stdout by default.  However, you can instantiate a `Test` object\r\nand then pipe it wherever you like.  The only limit is your imagination.\r\n\r\n#### t.test([name], [options], [function])\r\n\r\nCreate a subtest.\r\n\r\nIf the function is omitted, then it will be marked as a \"todo\" or\r\n\"pending\" test.\r\n\r\nIf the function has a name, and no name is provided, then the function\r\nname will be used as the test name.  If no test name is provided, then\r\nthe name will be `(unnamed test)`.\r\n\r\nThe function gets a Test object as its only argument.  From there, you\r\ncan call the `t.end()` method on that object to end the test, or use\r\nthe `t.plan()` method to specify how many child tests or asserts the\r\ntest will have.\r\n\r\nIf the function returns a `Promise` object (that is, an object with a\r\n`then` method), then when the promise is rejected or fulfilled, the\r\ntest will be either ended or failed.\r\n\r\nIf the function is not provided, then this will be treated as a `todo`\r\ntest.\r\n\r\nThe options object is the same as would be passed to any assert, with\r\ntwo additional fields that are only relevant for child tests:\r\n\r\n* `timeout`: The number of ms to allow the test to run.\r\n* `bail`: Set to `true` to bail out on the first test failure.\r\n* `autoend`: Automatically `end()` the test on the next turn of the\r\n  event loop after its internal queue is drained.\r\n\r\n#### t.tearDown(function)\r\n\r\nRun the supplied function when `t.end()` is called, or when the `plan`\r\nis met.\r\n\r\nNote that when called on the root `tap` export, this also triggers\r\n`autoend` behavior.\r\n\r\n#### t.autoend()\r\n\r\nAutomatically end the test as soon as there is nothing pending in its\r\nqueue.\r\n\r\nThe automatic end is deferred with a `setTimeout`, and any new action\r\nwill cancel and re-schedule the timer.  Nonetheless, calling this\r\nmethod means that any slow asynchronous behavior may be lost, if it\r\ncomes after the `end()` is auto-triggered.\r\n\r\nThis behavior is triggered on the root `tap` object when\r\n`tap.tearDown()` is called.\r\n\r\n#### t.plan(number)\r\n\r\nSpecify that a given number of tests are going to be run.\r\n\r\nThis may only be called *before* running any asserts or child tests.\r\n\r\n#### t.end()\r\n\r\nCall when tests are done running.  This is not necessary if `t.plan()`\r\nwas used, or if the test function returns a Promise.\r\n\r\nIf you call `t.end()` explicitly more than once, an error will be\r\nraised.\r\n\r\n#### t.bailout([reason])\r\n\r\nPull the proverbial ejector seat.\r\n\r\nUse this when things are severely broken, and cannot be reasonably\r\nhandled.  Immediately terminates the entire test run.\r\n\r\n#### t.passing()\r\n\r\nReturn true if everything so far is ok.\r\n\r\nNote that all assert methods also return `true` if they pass.\r\n\r\n#### t.comment(message)\r\n\r\nPrint the supplied message as a TAP comment.\r\n\r\nNote that you can always use `console.error()` for debugging (or\r\n`console.log()` as long as the message doesn't look like TAP formatted\r\ndata).\r\n\r\n#### t.fail(message, extra)\r\n\r\nEmit a failing test point.  This method, and `pass()`, are the basic\r\nbuilding blocks of all fancier assertions.\r\n\r\n#### t.pass(message)\r\n\r\nEmit a passing test point.  This method, and `fail()`, are the basic\r\nbuilding blocks of all fancier assertions.\r\n\r\n#### t.pragma(set)\r\n\r\nSets a `pragma` switch for a set of boolean keys in the argument.\r\n\r\nThe only pragma currently supported by the TAP parser is `strict`,\r\nwhich tells the parser to treat non-TAP output as a failure.\r\n\r\nExample:\r\n\r\n```\r\nvar t = require('tap')\r\nconsole.log('this non-TAP output is ok')\r\nt.pragma({ strict: true })\r\nconsole.log('but this will cause a failure')\r\n```\r\n\r\n### Asserts\r\n\r\nThe `Test` object has a collection of assertion methods, many of which\r\nare given several synonyms for compatibility with other test runners\r\nand the vagaries of human expectations and spelling.  When a synonym\r\nis multi-word in `camelCase` the corresponding lower case and\r\n`snake_case` versions are also created as synonyms.\r\n\r\nAll assertion methods take optional `message` and `extra` arguments as\r\nthe last two params.  The `message` is the name of the test.  The\r\n`extra` argument can contain any arbitrary data about the test, but\r\nthe following fields are \"special\".\r\n\r\n* `todo` Set to boolean `true` or a String to mark this as pending\r\n* `skip` Set to boolean `true` or a String to mark this as skipped\r\n* `at` Generated by the framework.  The location where the assertion\r\n  was called.  Do not set this field.\r\n* `stack` Generated by the framework.  The stack trace to the point\r\n  where the assertion was called.  Do not set this field.\r\n\r\n#### t.ok(obj, message, extra)\r\n\r\nVerifies that the object is truthy.\r\n\r\nSynonyms: `t.true`, `t.assert`\r\n\r\n#### t.notOk(obj, message, extra)\r\n\r\nVerifies that the object is not truthy.\r\n\r\nSynonyms: `t.false`, `t.assertNot`\r\n\r\n#### t.error(obj, message, extra)\r\n\r\nIf the object is an error, then the assertion fails.\r\n\r\nNote: if an error is encountered unexpectedly, it's often better to\r\nsimply throw it.  The Test object will handle this as a failure.\r\n\r\nSynonyms: `t.ifErr`, `t.ifError`\r\n\r\n#### t.throws(fn, [expectedError], message, extra)\r\n\r\nExpect the function to throw an error.  If an expected error is\r\nprovided, then also verify that the thrown error matches the expected\r\nerror.\r\n\r\nIf the function has a name, and the message is not provided, then the\r\nfunction name will be used as the message.\r\n\r\nIf the function is not provided, then this will be treated as a `todo`\r\ntest.\r\n\r\nCaveat: if you pass a `extra` object to t.throws, then you MUST also\r\npass in an expected error, or else it will read the diag object as the\r\nexpected error, and get upset when your thrown error doesn't match\r\n`{skip:true}` or whatever.\r\n\r\nFor example, this will not work as expected:\r\n\r\n```javascript\r\nt.throws(function() {throw new Error('x')}, { skip: true })\r\n```\r\n\r\nBut this is fine:\r\n\r\n```javascript\r\n// note the empty 'expected error' object.\r\n// since it has no fields, it'll only verify that the thrown thing is\r\n// an object, not the value of any properties\r\nt.throws(function() {throw new Error('x')}, {}, { skip: true })\r\n```\r\n\r\nThe expected error is tested against the throw error using `t.match`,\r\nso regular expressions and the like are fine.  If the expected error\r\nis an `Error` object, then the `stack` field is ignored, since that\r\nwill generally never match.\r\n\r\nSynonyms: `t.throw`\r\n\r\n#### t.doesNotThrow(fn, message, extra)\r\n\r\nVerify that the provided function does not throw.\r\n\r\nIf the function has a name, and the message is not provided, then the\r\nfunction name will be used as the message.\r\n\r\nIf the function is not provided, then this will be treated as a `todo`\r\ntest.\r\n\r\nNote: if an error is encountered unexpectedly, it's often better to\r\nsimply throw it.  The Test object will handle this as a failure.\r\n\r\nSynonyms: `t.notThrow`\r\n\r\n#### t.equal(found, wanted, message, extra)\r\n\r\nVerify that the object found is exactly the same (that is, `===`) to\r\nthe object that is wanted.\r\n\r\nSynonyms: `t.equals`, `t.isEqual`, `t.is`, `t.strictEqual`,\r\n`t.strictEquals`, `t.strictIs`, `t.isStrict`, `t.isStrictly`\r\n\r\n#### t.notEqual(found, notWanted, message, extra)\r\n\r\nInverse of `t.equal()`.\r\n\r\nVerify that the object found is not exactly the same (that is, `!==`) as\r\nthe object that is wanted.\r\n\r\nSynonyms: `t.inequal`, `t.notEqual`, `t.notEquals`,\r\n`t.notStrictEqual`, `t.notStrictEquals`, `t.isNotEqual`, `t.isNot`,\r\n`t.doesNotEqual`, `t.isInequal`\r\n\r\n#### t.same(found, wanted, message, extra)\r\n\r\nVerify that the found object is deeply equivalent to the wanted\r\nobject.  Use non-strict equality for scalars (ie, `==`).\r\n\r\nSynonyms: `t.equivalent`, `t.looseEqual`, `t.looseEquals`,\r\n`t.deepEqual`, `t.deepEquals`, `t.isLoose`, `t.looseIs`\r\n\r\n#### t.notSame(found, notWanted, message, extra)\r\n\r\nInverse of `t.same()`.\r\n\r\nVerify that the found object is not deeply equivalent to the\r\nunwanted object.  Uses non-strict inequality (ie, `!=`) for scalars.\r\n\r\nSynonyms: `t.inequivalent`, `t.looseInequal`, `t.notDeep`,\r\n`t.deepInequal`, `t.notLoose`, `t.looseNot`\r\n\r\n#### t.strictSame(found, wanted, message, extra)\r\n\r\nStrict version of `t.same()`.\r\n\r\nVerify that the found object is deeply equivalent to the wanted\r\nobject.  Use strict equality for scalars (ie, `===`).\r\n\r\nSynonyms: `t.strictEquivalent`, `t.strictDeepEqual`, `t.sameStrict`,\r\n`t.deepIs`, `t.isDeeply`, `t.isDeep`, `t.strictDeepEquals`\r\n\r\n#### t.strictNotSame(found, notWanted, message, extra)\r\n\r\nInverse of `t.strictSame()`.\r\n\r\nVerify that the found object is not deeply equivalent to the unwanted\r\nobject.  Use strict equality for scalars (ie, `===`).\r\n\r\nSynonyms: `t.strictInequivalent`, `t.strictDeepInequal`,\r\n`t.notSameStrict`, `t.deepNot`, `t.notDeeply`, `t.strictDeepInequals`,\r\n`t.notStrictSame`\r\n\r\n#### t.match(found, pattern, message, extra)\r\n\r\nVerify that the found object matches the pattern provided.\r\n\r\nIf pattern is a regular expression, and found is a string, then verify\r\nthat the string matches the pattern.\r\n\r\nIf the pattern is a string, and found is a string, then verify that\r\nthe pattern occurs within the string somewhere.\r\n\r\nIf pattern is an object, then verify that all of the (enumerable)\r\nfields in the pattern match the corresponding fields in the object\r\nusing this same algorithm.  For example, the pattern `{x:/a[sdf]{3}/}`\r\nwould successfully match `{x:'asdf',y:'z'}`.\r\n\r\nThis is useful when you want to verify that an object has a certain\r\nset of required fields, but additional fields are ok.\r\n\r\nSynonyms: `t.has`, `t.hasFields`, `t.matches`, `t.similar`, `t.like`,\r\n`t.isLike`, `t.includes`, `t.include`, `t.contains`\r\n\r\n#### t.notMatch(found, pattern, message, extra)\r\n\r\nInterse of `match()`\r\n\r\nVerify that the found object does not match the pattern provided.\r\n\r\nSynonyms: `t.dissimilar`, `t.unsimilar`, `t.notSimilar`, `t.unlike`,\r\n`t.isUnlike`, `t.notLike`, `t.isNotLike`, `t.doesNotHave`,\r\n`t.isNotSimilar`, `t.isDissimilar`\r\n\r\n#### t.type(object, type, message, extra)\r\n\r\nVerify that the object is of the type provided.\r\n\r\nType can be a string that matches the `typeof` value of the object, or\r\nthe string name of any constructor in the object's prototype chain, or\r\na constructor function in the object's prototype chain.\r\n\r\nFor example, all the following will pass:\r\n\r\n```javascript\r\nt.type(new Date(), 'object')\r\nt.type(new Date(), 'Date')\r\nt.type(new Date(), Date)\r\n```\r\n\r\nSynonyms: `t.isa`, `t.isA`\r\n\r\n### Advanced Usage\r\n\r\nThese methods are primarily for internal use, but can be handy in some\r\nunusual situations.  If you find yourself using them frequently, you\r\n*may* be Doing It Wrong.  However, if you find them useful, you should\r\nfeel perfectly comfortable using them.\r\n\r\nPlease [let us know](https://github.com/isaacs/node-tap/issues) if you\r\nfrequently encounter situations requiring advanced usage, because this\r\nmay indicate a shortcoming in the \"non-advanced\" API.\r\n\r\n#### t.stdin()\r\n\r\nParse standard input as if it was a child test named `/dev/stdin`.\r\n\r\nThis is primarily for use in the test runner, so that you can do\r\n`some-tap-emitting-program | tap other-file.js - -Rnyan`.\r\n\r\n#### t.spawn(command, arguments, [options], [name], [extra])\r\n\r\nSometimes, instead of running a child test directly inline, you might\r\nwant to run a TAP producting test as a child process, and treat its\r\nstandard output as the TAP stream.\r\n\r\nThat's what this method does.\r\n\r\nIt is primarily used by the executable runner, to run all of the\r\nfilename arguments provided on the command line.\r\n\r\nThe `options` object is passed to `child_process.spawn`, and can\r\ncontain stuff like stdio directives and environment vars.\r\n\r\nThe `extra` arg is the same that would be passed to any assertion or\r\nchild test, with the addition of the following fields:\r\n\r\n* `bail`: Set to `true` to bail out on the first failure.  This is\r\n  done by checking the output and then forcibly killing the process,\r\n  but also sets the `TAP_BAIL` environment variable, which node-tap\r\n  uses to set this field internally as well.\r\n* `timeout`: The number of ms to allow the child process to continue.\r\n  If it goes beyond this time, the child process will be forcibly\r\n  killed.\r\n\r\n#### t.addAssert(name, length, fn)\r\n\r\nThis is used for creating assertion methods on the `Test` class.\r\n\r\nIt's a little bit advanced, but it's also super handy sometimes.  All\r\nof the assert methods below are created using this function, and it\r\ncan be used to create application-specific assertions in your tests.\r\n\r\nThe name is the method name that will be created.  The length is the\r\nnumber of arguments the assertion operates on.  (The `message` and\r\n`extra` arguments will alwasy be appended to the end.)\r\n\r\nFor example, you could have a file at `test/setup.js` that does the\r\nfollowing:\r\n\r\n```javascript\r\nvar tap = require('tap')\r\n\r\n// convenience\r\nif (module === require.main) {\r\n  tap.pass('ok')\r\n  return\r\n}\r\n\r\n// Add an assertion that a string is in Title Case\r\n// It takes one argument (the string to be tested)\r\ntap.Test.prototype.addAssert('titleCase', 1, function (str, message, extra) {\r\n  message = message || 'should be in Title Case'\r\n  // the string in Title Case\r\n  // A fancier implementation would avoid capitalizing little words\r\n  // to get `Silence of the Lambs` instead of `Silence Of The Lambs`\r\n  // But whatever, it's just an example.\r\n  var tc = str.toLowerCase().replace(/\\b./, function (match) {\r\n    return match.toUpperCase()\r\n  })\r\n\r\n  // should always return another assert call, or\r\n  // this.pass(message) or this.fail(message, extra)\r\n  return this.equal(str, tc, message, extra)\r\n})\r\n```\r\n\r\nThen in your individual tests, you'd do this:\r\n\r\n```javascript\r\nrequire('./setup.js') // adds the assert\r\nvar tap = require('tap')\r\ntap.titleCase('This Passes')\r\ntap.titleCase('however, tHis tOTaLLy faILS')\r\n```\r\n\r\n#### t.endAll()\r\n\r\nCall the `end()` method on all child tests, and then on this one.\r\n\r\n#### t.current()\r\n\r\nReturn the currently active test.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}